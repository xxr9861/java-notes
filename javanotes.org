#+TITLE: Learning java in my own way


* java






** java, sql, parallels : helsinki java sms example : fixed

I see that there are parallels with SQL and java. 

Create a hashmap and populate that with the put() command. 

Hashmap is like an array-list and object and it contains objects. 

Like a table with columns or attributes

The table is a table for library and contains two attributes or columns, the name of the book and the name of the lender. The name of the book or the book can be a unique object, we define it separately. The name of the lender is just a string or if we want we can make it an object with its own attributes. 
This is one way of thinking about it. Seems like you can learn some more SQL and relational algebra while you are at it. 

Consider the object sms or the class sms, class sms that makes the object sms. Whatever. 

We consider sms. It has two attributes, string, string. That is nice. 
One way to think about sms is that one string is the name of the sender and the other string is the message itself. 

You can create a lot of sms object with new. 

Consider an array-list of sms objects. Array-list can be visualized as a table with a single column. In this case the column will contain many sms objects. List of sms objects in this table. 

Other kind of tables are like hashmaps. Hasmap table has two columns, one is usually some string and the other is usually some kind of object. 

What could be the use of a hashmap object, idk. 

Consider the class ebook, this has two attributes, string and array-list of string

All of this makes the whole thing a lot more easier than it used to be. 

Trying to think. 

So any object and you represent it with an empty box, this is a table, it can be but not always. 

Objects have related methods or functions, we do not care about any function unless that function returns an object in the sense that the object is not string or int but only if the object is a constructed object or an array-list or a hashmap. Do collections and sets count? idk, for this moment. 

The objects that have constructors that can be empty, then an empty box

Objects whose constructors consists of attributes like int or string. Empty  box with a list of that. 

Object whose constructors have as attributes lists like hashmap or array-list or a combination of string or array-list, string and hashmap, int and array-list. Any of that kind of combination. . this is a proper box with a table. 

Consider only those methods that return objects like array-list or hashmap or other constructed objects. 


** java : objects fixed

There are n number of objects in your files, they can all be brought forth independently. 

n objects. how ever they are arranged in some peculiar ways.
Objects can contain arraylists
Objects can contain other objects
Hashmap can contain objects

Arraylist you can get this out and put it into a set or collection
Hashmap, you can extract the key or the values and then put them into a set or a collection

n objects, there are no lists like arraylist or hashmaps

Objects can have methods, we would only consider those methods that have a return type of an object

object1--method1--object2

Objects are not functions but objects can have functions that do something to other objects. Like generate other objects

But all of that depends on the main. 


** java: making sense of objects fixed

Objects, those objects like say pen, paper or name of people, the sort of objects that are just an individual identity and nothing to do with storing in lists or whatever are made up of properties or attributes. 

Like an object say a person, has a name, can walk, run, sing, dance, has an address and so on. So lots of attributes. 
Now the attributes are there. 

The object can also have functions, objects are sort of placeholders for functions. 

So each object can have so many functions. Object. Fun1(), object. Fun2() and so on. 
These functions are attached to the object in question. 

It is possible to import an external function and make it look like it is the function of that object itself. 

So basically an object that burrows a function from another object and presents it as its own. 

No it is not a superclass or an abstract class or an interface. None of that, it is just a separate class. 

#+BEGIN_SRC java

object.fun3()
and fun() calls a function from object2
how would you go about importing this function of another object
fun2()
new object2;

fun2 -->> object2.fun_to_be_imported()
so each time you call fun2(), you are calling that other function.

#+END_SRC


** reference variables, i think you got the wrong idea here : fixed

In a class declaration, if you are referring to other class functions, you have to refer to those other classes, you do so with reference variables. 

OtherClass otherobject; <<-- otherobject is an object derived from the other class. 

Now you can call the functions afforded by that other class. 

Now why was such a thing done. 

You see, you have this object which has attributes and like all objects it has a plethora of functions. 
Now we have variations of this object, which means the functions and their implementations would vary. This calls for segregating the functions into two groups, those that change a lot and those that are fairly constant. For those which are constant, put them into the abstract class the super abstract class, so that all the sub classes would inherit the code by polymorphism, (is this right?)
Strike that, not polymorphism but the correct term is inheritance. 

And those that differ in their implementation can be put into an interface that the classes would inherit but they would have their own implementation. 
So far so good. 

We can do further things as regards the former use of super abstract classes where we put the implementations of common and constant functions. 

We could take the functions out of that class and put it in a separate class unrelated by inheritance or extension, not a superclass or interface, but a separate unique object. 
And the functions are kept there separately

So the objects and the way you present them regarding the functions or maintainability of it is basically three kinds. The one with the superclasses affording inheritance, the one where we use interfaces, (is this polymorphism), and the last one where we separate the functions from the parent class and put it in a separate class unrelated by inheritance or otherwise. 

Note: all of this is for the sole purpose of making maintenance of code easier. 








** observer pattern : fixed

Three components, subject, observer and display. Subject has a list of observers, like in an array-list. Functions like add observers to this list, remove observers from this list and notify observers in this list. Observer(subject)

That dis not make any sense. 

Not very well defined, this observer pattern. 

What do we have are basically two parts, the subject and the observer. In the main you have to create a subject and then an observer. That is pretty much it. 

The subject has attributes, has functions, has lists. It keeps observers into a list, hence the related functions, addobserver(), removeobserver(), notifyobserver(). 

Subject is kind of passive, you call it or create it once and that is it. The functions that populate observer into the list of subject like addobserver(), removeobserver(), notifyobserver() are called from the observer object. 
 
The observer takes subject object as args in its constructor and then uses that to call the functions of subject. So subject is kind of like the inert passive dead-body with inert organs and observer is using those organs borrowed from subject. 
Sorry, it is a little diff. 

It is like say two wheels which are connected by a drive belt. The two wheels are the two objects and the drive belt represents the functions that connect the two. Create wheel1 and wheel2 now trigger wheel1, which would then trigger wheel2. But all of the underlying functions that connect the two are hidden. 
 
Subject and observer. Trigger subject, which then triggers observers. 
Subject and observer, subject has a list of observers. Trigger subject which then would trigger the list of observers. 
 
Ignore all those interfaces or classes or super-classes for the moment. These two, subject and observer are distinct classes with no such relation between them. Apart from that, one object has a list which is populated with the other object. And the other object calls or uses the function of the other object. The constructor of observer is that pinhole type, like it makes it automatically register or populate itself into subjects list on its creation. The creation of the object brings into existence so many functions and the mandatory actions or the pre-condition (for all of this to work) is put into the constructor, so that on its creation all the prior stuff is already done. So all you are left to do is the other stuff. 
 
Do not really understand the stuff about separating out the functions into the separate interfaces. Seems kind of daft, adding to the complexity. Maybe this can be done as an afterthought. 
 
To keep things simple, there are two major components, the subject and the observer. 
 
So again we have two objects, one of them has a list in which is kept the other object. And then that object will run a function of those other object in the list. And then the other object uses some functions of the first object. 
 
It is like the two classes are intertwined in the sense that one of them has a list for the other object and both of them use the function of the other guy. One creates a list of the other object, and the second one takes the first object as argument in the constructor. 
 
Now to keep things simple that is using only two main components and not more than that, you have basically two main classes and then squeeze out some of the functions and put them into some interfaces, which can either be implemented by the one or the other class. So irrespective of how complex it might get in the sense of how many sub classes that you spawn off, there would still be two main pivot point in sense of the two main abstract classes. 
 
So observer pattern, two main classes, the concept being one is the subject and the other is the observer, garnish with a lots of interfaces and however much sub classes. 
 
There is an observer pattern API, how do you use that?

The API goes like the following. 
 
There are two parts. As observer pattern has two main parts. The subject and the observer. Or observer and the observable. 

 

The interface observer and the super-class observable. You put your observer classes to extend the observer interface. And the observable classes to extend the super-class observable. 
That is nice. 

There should be built in functions, which we can explore by going on into the IDE and checking out all the possibilities. But then we do not have to invest in something that is like built in that we have to have a working knowledge of the pattern on which it is based on. It could have variations and maybe do different things and might change as it evolves with incriminating versions, the pattern behind it would be the same. 

Keep the background pattern theory simple and planted. No mucking about. 

Decorator pattern as just an example, just keep it simple and there is no need to bring in any kind of complexity. 

How do you go about doing it. 

Imagine you have a beverage shop and you sell some kind of beverage, and there are addons for that beverage like say addon one, two and three and four and so on. Now you could sell them as beverage only, or beverage plus one, or beverage plus three or beverage plus two plus four and so on. There are so many different kind of combinations that are possible. So what do you do is go to the decorator pattern. 

See all of these like the beverage and the addons like one, two, three and so on are of the same kind or type or basically the same kind of object. 

The addons object have a constructor that takes the main beverage or other addons as an argument. 
That is the basic premise of this decorator pattern, you have a bunch of objects and then the objects can take other objects as arguments and since they have similar kind of attributes, like say cost or description or whatever, you can chain together the two and make a combination of the two and so on. Basically you can build one on top of the other. I am blabbering, this one is more clear than the observer pattern. 

So decorator pattern is easier than your observer pattern. 

Now they are telling me about this io package in java, so what are you going to do about it. The thing is that they are throwing around terms like API and stuff like that and these are prewritten code in the java library basically what is going on is that you have the code which reflect or which are based on what you just learnt like the design pattern stuff that is like for the decorator pattern you have java packages / API that is a particular java package, in this case the decorator package. And there would be some quirks but then that is all about it. 

And then there are other packages that reflect or are similar to the decorator pattern, in this case the java io package. 

Now that you know about the decorator pattern you could look into this decorator package. 
Now that you know about the decorator pattern you could look at the io package. 

Have to hunt for examples in java that use io package or the decorator package. 
Need to make this simple, this is regarding the factory pattern. 

The whole problems seems to have come about from the whole pizza thing. We have pizza object and there are whole lot of varieties and then there is the whole nightmare about maintainers of all these concrete implementations of pizza varieties. 


** factory pattern : fixed

Enter factory pattern

So here is how it goes, the whatever receives a string query about a type of pizza to dispense and this goes to the factory object as string. 

So basically it would do if so and so string then return so and so pizza object. That is the function of factory. This factory object returns different pizza objects. Object a takes a string argument and returns object b. 

So factory object has nothing to do with the pizza object, all it does is return pizza object. 
Then there is another object, the store object, the store object references factory object and makes it to create a pizza object. 

So store object is not related to the factory object and which is again not related to the pizza object. 

What could be the use of this? for one maintenance maybe, you have three separate classes not related to each other and they are referencing one another. The store calls on the factory and the factory returns the pizza object. 

So three objects, the store, factory and pizza. 

In fact in the main you would have to create only the store object, which would then take a string as argument, it would create a factory object and then pass the string to it. And the factory would produce the pizza object. 

So in the main, you do not have to create the factory or the pizza objects. The only thing that you have to create is the store object which takes a string argument. 

That is all. The factory object is created internally, you do not have to worry about it and similarly the pizza objects are all taken care of, you do not have to manually create any of them. 
Store, factory and pizza. Where you only create the store object and pass a string to it. 
Store create the factory and factory creates the pizza. 

This is the factory pattern. 

You can see that this affords us other possibilities. 

Say you have two or three types of store objects, and two or three types of factory object. 

You create a particular type of store object and pass a string to ti. It would create the appropriate factory depending on the string and then the factory would create the pizza. 

As for the pizza object, you could if there are many combinations possible as regards the ingredients, do something like the decorator pattern for the pizza stuff. 

I am missing something, so what is the use of this factory pattern. 

There is difference between simple factory and factory. So the question arises what I just did was what?
See reddit for diff between simple factory and factory. 

I use this separate lingo, they say that there is the super types or the super classes or the abstract classes and then there are those that extend those and they are the concrete classes. 
So the question comes that there is a single branch or there is possible more branches down the road and in that case which one is the abstract and which one is the concrete. The top most would be the abstract, even if we could make objects out of them we would not make objects out of the top tier classes and to enforce this they use the keyword abstract. But then if there are more than one branches and there are sub-classes or more sub-classes after the concrete classes then what. 

We cannot do something like down the branch add the keyword abstract, can we. 

Maybe it is just an understanding that you have branching and if that is one stage of branching then you have one the top tier one that would be called the abstract and to enforce that in good measure throw in the keyword abstract and then the rest beneath it are the concretes. 
Factory pattern is getting complicated, the first one was very simple

You had three basic objects, store, factory and pizza. 

Store would reference the factory object and then factory object would produce the pizza object. 
Simple. 

Another kind I am seeing is

Store takes string args for the kind of pizza and this goes to an if then else if kind of conditional which then calls on pizza object. The pizza object internally calls on the factory object to provide all the ingredients. 

Store to pizza object to factory object. 

Factory object is not even in the picture, we deal with the store object the store creates the pizza object and the pizza object takes care of the factory or deals with the factory internally. And this way factory is hidden away. 

All in all I am not very sure about this whole affair. 

There are functions and these functions are tied to objects. We have to create an object to use the function provided by it. The object can then call on other objects or reference other objects (internally, behind the doors, under the bonnet) so we do not have to deal with all that. These are parts that are hidden away. 

So what is the factory pattern. Idk, we only had to create a store object and pass to it string arguments about the kind of pizza we want. All the functions of the pizza object and all the functions of the factory object are never seen by us. 

If this were functional programming and all the steps were essential we would have to write everything down step by step and use something like the if else else if or else if or case ecase sort of conditional to execute a specific block of code that would give us the product that we want. 

This is doable, sort of. 

The dependency inversion principle. 

There are components and they are high level components and low level components and there is a dependency among them and it is directional that is the high level components depend on the low level components right? like if pizza is the high level component and the low level components are the ingredients that are used to make the pizza then the ingredients do not depend on the pizza but rather the pizza depends on the ingredients. 

Another thing is that the components here are not really of one class but separate distinct classes. There is no relation between the classes. 

Ingredients are ingredients and pizza is pizza. Separate classes and here we are talking about dependency and there is a directional nature of this dependency and here we are talking about the direction of this dependency. 

The principles say, "depend on abstractions and do not depend on concrete implementations"
So there is a directional way in which the pizza object depends on the ingredients. We cannot flip this, can we? no we cannot but what they are saying is that the pizza object should depend on the abstract classes of ingredients rather than the concrete implementation of ingredients. Is that what they are saying. 

So if there are two objects and the two are related in the sense that one refers to the other then make it so that the head of ones arrow points to such things as interfaces and abstract classes rather than to concrete classes. 

That makes sense, say you have two objects a and b. A refers to b. A should take an abstract class of b or an interface that is implemented by b. 

How is this dependency inversion?

We were thinking of three blobs of code, the pizza store, pizza and factory. 
And one of the object relates to the other object in some ways and this relations might be directional. 
Each object or class or say a blob of distinct class abstract or concrete is one blob. But then again it can be resolved into two parts the higher abstract part and the lower concrete part. 

Consider the three blobs, the store, pizza and factory. And then relate them in such a way that. 

store--> pizza --> factory
concrete store --> abstract pizza, concrete pizza --> abstract factory. 

So there are discrete distinct blobs of code and they are

concrete store + abstract pizza
concrete pizza + abstract factory

In this way these blobs are not tightly coupled. That is

store + pizza -->> lightly coupled
pizza + factory --> lightly coupled

Basically if of the two objects, say store and pizza, one or the other were to change, the relation ship wont be affected. 

That again means one another thing and that is that while designing something and you have multiple objects and they somehow relate to one another then even as you are designing the thing and have yet to carve out or smooth out the concrete part of the code or the low level code blocks of objects you would be able to connect them up, low to high, low to high, without worrying about what the lower level implementations would be. 

This is important, there is a sequence here. Even if it might seem to go nowhere. 
#+BEGIN_SRC Java
new store();
mystore.orderpizza(cheese pizza);

#+END_SRC

So far so good. 

Remember we had basically three distinct objects, store, pizza and factory. 

Store to pizza and then to factory. 

I know it is confusing but bear with me. 

New store object;
#+BEGIN_SRC Java
mystore.orderpizza(cheese pizza);

#+END_SRC

Now this is a concrete implementation of a store. This is connected to pizza class, again loosely coupled to pizza object, not to the concrete pizza. 
#+BEGIN_SRC Java
Pizza = creeatepizza(cheese)

#+END_SRC

Now this goes down to some concrete pizza code and this references some high level factory. 

That did not explain it well but the book does seem to and yet I cannot explain it. 

Check out the figure in the page 158

Sorry 156

It is all right but the arrows make no sense. 
Hello

Hello, they forgot to tell us something about the factory pattern, the static keyword, it is there in factory. 

And then the use of the private keyword too. 

These guys are idiots, they should have told us about the static and the private keywords in the factory pattern. 

I kind of understand when you have a static variable but what does it mean to have a static method or class. 



** factory pattern : fixed

This is regarding the factory method on which I have been on for the past three days now and it is kind of getting annoying. 

OK so far I understand that factory pattern is just about the following kind of a situation. 

Imagine you have two objects/classes or whatever, one being the client and the other is the creator whi
Ch creates the products. Is that right, I messed up. 

One is the product and the other is the creator. 

Basically two blobs of code. I like to imagine an entire object, regardless of its deconstruction into sub-classes or specialization into interfaces, as a single compact blob. So in the above case the product class and the creator class are two solid blobs. 

Now here is what happens, the client class(this could be another blob) tells the creator class to return some product class objects and the creator class would return the product objects. 

So there is a kind of a relation. 

creator -- >> product

or maybe

client -- creator -- product

So where is the factory?

Factory is very much recognizable block of code, it might not be a whole class, a small function could look like a factory. 

It goes like this
#+BEGIN_CENTER
if blah blah
then return blah blah
else if blah blah
return blah blah
else if blah blah
return blah blah

#+END_CENTER

What that block of code is doing it checking against the passed string arguments and creating a relevant concrete product objects. 

This block of code, or blob of code is the factory pattern. 
You could keep that in the creator class as a method, or you could just pull it out into its own class 
And you could call the class as something like mygoodassfactory

And then stick the method in there. 

That is now the factory class with the factory method inside. 

The problem comes when they talk about factory pattern and abstract factory as different. 

So what is the difference between the two. 

The difference between the two is not really about the factory thing at all. 

What it is about is that the factory class that you created can be again be sub divided into more sub classes. So effectively you have created a super abstract class of factory and the sub-classes or the concrete implementation of factory. 

Basically you took the single blob of factory and divided it into two blobs the abstract blob and the concrete blob or blobs. 

The factory pattern, remember that familiar pattern of
#+BEGIN_CENTER
If blah blah

Then return blah blah

Else blah blah

Return blah blah

#+END_CENTER

This characteristic factory pattern is then shoved into the concrete factory sub-classes. 

Basically by resolving the factory into a separate class and then dividing the factory into abstract su
Per class and concrete sub-classes you have created an abstract factory. 

You can clearly see that abstract factory contains within itself the factory pattern. 

And also that you do not need to have a discrete factory class to have a factory pattern. 

There was too much jargon that was thrown around, like code to an abstraction rather than to an implementation. And such kind of thing. I get it that this is done to sort of insulate two pieces of code with another higher level of code. Now I am not making any kind of sense. There is a way to describe this. 
And still there are other facets left unanswered that is the classes or methods that are supposed to be declared as static or which of them should be private. 

They made a point about dependency inversion wrt the factory method or pattern. 
The thing is they showed two blobs, product and the creator and arrows come flying from creator and congregate at the products. 

So the arrows represent the dependency and if in this case the dependency is linear and unidirectional. 
Now enter factory pattern or rather more accurately factory class (even the pattern works, without the whole class deal_)

In this case the three parts are the creator, factory and the product. Now the arrows go from creator to factory. And from product to factory. And this they call as dependency inversion. At first glance, you could just take them at face value but I cannot really see any kind of inversion. 

All I see is

The creator calls on the factory and the factory then calls or returns the products, they all seem to be unidirectional. 

Remember what I told you about the classes or objects. 

Each of them is to be treated as a single blob of code. Now go ahead and divide each of those three blobs into two parts, the abstract or higher part and the lower part or the implementation part. 

And still the arrows point from

Creator to factory to products

Now the arrows would go in the following fashion. 

Concrete creator to abstract factory to concrete factory to concrete product; or creator low to factory high to factory low to product low. Idk, this is all very sketchy. If the arrows were pointing from low to high, they you can clearly see how the arrows are all pointing towards the abstract factory. This is the inversion in action. 

That junction there, concrete creator to abstract factory ( to concrete factory ) to concrete product. 
Concrete creator to abstract factory to concrete product. 

This is important. For this demarcation between creator and the products is done. So if you were to make changes to products, the code related to the creator block is unaffected and vice versa. You would just need to make some changes additions or deletions to the products and the concrete factory. Creator is left untouched. 



** java keyword: protected : fixed

Weird observation: in java they used the keyword protected on a method, the class is not protected but the method is protected, it might be that a variable could be declared protected. What this means is that the class or method or variable are not visible outside of the package. Idk, I usually use only one package, I have not got the expertise to write something so extensive that more than one package will be required. 


** singleton pattern : fixed

Back to java stuff. This is regarding the whole deal with singleton pattern. 
There is nothing more to it, but apart from the code or pieces of code that make it the way it is, it is basically a single blob of object. And this blob of object has the specialty that there is only one instance of it at all times. If you look at the construction of the code you would notice that there are no public constructor for this object, there are no constructor, period. There is one constructor that says, private myclass() and that is it. That is the constructor. 
(there is still doubt about this with me, but we will come back to it later on)
And the code has a special method, and this method is public method, it will return the object the first time and when the function is called again, it would return the preexisting object back, not creating another instance of the object. 
That is how the singleton works. But this is regarding the internals or how the singleton works. We should be more concerned about how to use this singleton pattern. 

Singleton pattern:

So there is and example that has been given in the book and it goes like this. 
You have a chocolate factory, say this is an object and it has certain methods like draining of the chocolate vat, or filling of the chocolate vat and varied other methods that I am not interested in. There is this objective and that is to write the code in such a way that there is at any time more than one instance of this draining method/ or the object that carries that method. 
So the best solution would be to, I figured why not take that single method that is concerned with drainage and then put it in an object, another object and make that object a singleton. Now you have two objects the chocolate factory and the singleton method that is concerned with the drainage of the chocolate vat. So at any time even if you have multiple instances of the chocolate factory you only have only one instance of the singleton. In this way there would be no danger of accidentally draining the chocolate vat. 

Now here is the potential problem, the factory and the chocolate vat are part of the same structure, unless of course you think that the chocolate factory object and the singleton object are two different objects. Think this might not work and since there would be reference or connection between a multiple instance chocolate factory and the singleton class, it would lead to compiler error. This would probably not work. 

Now here is another way this could work and that is to make the entire chocolate factory a singleton this means that at any time there is a single chocolate factory object and hence there would be a single instance of the drainage functionality and hence this might work. 
Still another bit to it and that is accounting for multi-threaded applications and in this case the addition of a single keyword fixes it. 




Note the relationship between a singleton pattern and the keywords static and private. 

Private method or private constructor, so that nobody is able to access the constructor. And then there is the use of the keyword static in the method that returns the object but is not a constructor. 

Method that returns the object but is not a constructor. 
Again, what was that. 

Nope, this also works as

New object, return the created object. 
Same thing over here, new singleton, return the singleton object. 
But prior to doing any of that it would check to see if any other instance is running or not. 
If there is no instance of the singleton

or

singleton == null

Then very well, go ahead and create one and return it but if the contrary then do not create anything but return the existing instance. 

Again, the sentence. " no constructor but the method return an object with new" is a bit odd. 
So I am done with the singleton pattern, now for the command pattern. 
Finally we are making some kind of progress. It is is not about the code but rather what is that blob of stuff doing. That is what matters, for instance the factory pattern, and how it is but a specific pattern of code, very easily recognizable and how it could be resolved or written into a separate object and then again how that could be divided into abstract and concrete parts inside which again the pattern would be housed. So that was the factory pattern, the factory object and the abstract factory which is but just a name given to a part of it. 

Then we had the singleton pattern, this was just a construct with special keywords but the function of it being to have only one instance of the object. 


** command pattern : fixed

In case of the command pattern the following painting has been presented
A set of blobs, or say appliances, the bulb, the radio etc each with their set of dials and switches like the on and off switch or the volume up and volume down switches. 
Now say you have a super blob called appliances or devices and this would contain smaller blobs by the name of radio, bulb, TV and so on. 
Basically this is a single blob. 

Now in case of room we have on and off switch which switch on the lights or switch them off. 

We make an object called the lightsOnCommand. And then we also make another object the volumeUpCommand, this could apply to radio object or the TV object. 

All of these objects would have a common interface, the command interface. 

Now you have two blobs, the appliances blob and the command blob. 
Sorry wrong track, let us back track. 

Two super blobs, the command object and the appliances object. 
LightsOnCommand references a light object. VolumeUpCommand references a radio or TV object. Both these objects, lightsOnCommand and volumeUpCommand have a super higher abstract method called execute. Depending on the individual implementation, execute might call the on method on the object or the volume up method on the object. 

So to summarize. 

At the beginning you have a bunch of appliances with a set of commands. 
Now you take all those commands and put them aside. Now we create another super object called the command object and this is subclassed as commands that do some generic stuff. 
Like commands that turn up the volume, this might apply to radio, TV, and so on. There might be another command that would switch on a light and this might apply to such appliances such as the table lamp the ceiling lamp, the tube-light and so on. 

So till now we have two blobs. 

The lightsOnCommand is constructed in the following way. 
It would accept a light object or object of type light. Again we might have to subclass those objects like tube-light, table-lamp or ceiling light as light objects. 
So all of those objects will be compatible with this type. 
And then there is this command called execute this is an abstract command in the command object that has individual implementations but where. The implementations are there in objects such as the lightsOnCommand, there is one implementation, for the volumeUpCommand there is another implementation. 
This will need to be diagrammed. 

There is a small piece of confusion in here and that is as follows. The kind of appliance objects that you have used are too varied. Let us make them sort of homogeneous. 
Say the appliances in question are like garage doors, building doors, house doors, barn doors, house windows and so on. 

So all of them have this common function that is the doorOpen function. 
Now I do not want to manually create these objects and then execute that function for them. I want a kind of a wrapper that would take those objects as arguments and then press those buttons or execute those functions for them. 

So there is an generic object called the doorOpenObject and this guy takes all of those types of objects and then internally it would have a function called execute which would pass the type of the object to it and then do the relevant actions. In this case the relevant action would be
#+BEGIN_SRC Java
execute(object object){
this.object =object;
object.doorOpen();

#+END_SRC

that is the function.


So basically you have to create the house door and then create a doorOpenFunction object and do
DoorOpenFunction. Execute(house door object); or doorOpenFunction. Execute(building door object); and all that it would do is open the door. 
So this is the command pattern. 

When you have a bunch of objects with similar kind of methods and you do want to delegate the function of pressing those buttons or executing those functions to another object, in this case that guy to whom this task is outsourced is called the command object. Just an ordinary object having a higher abstract generic function called the execute function that does some kind of generic action, like open the door. 

This needs more polishing and explaining. 

You could take this further more, say you have the appliance objects and since they are all under the umbrella of the same interface object or abstract class, you could add them into a list or array-list. 
You could then loop through this list and then on each item of the list execute the command pattern object, so on each object the execute function is operated on. 
You could further extend this, you could make a command called the lightsOffCommand object and then a volumeUpcommand object and so on. 

This could kind of get messy in the following way. You would have a multitude of appliances that would be like the radio TV and so on and then there would be the lights based objects like the table lamp the ceiling lamp etc and other type of appliances, you could group them as the following the radio appliances which would be the super abstract group which would contain those objects and then you would have the light based appliances which would be the super abstract group which would then contain the objects like  table lamp or whatever. 

So there is a single stage of branching. You cannot put a super class on top of radio based and light based object classes but you could make them implement a common interface, that way all the appliances will have a common type. 

Wish I could make this simpler, the thing is this is not a simple thing. Basically what has been done i
S that they have taken a simple stuff and then made it complicated. 
Let us do a very simple example. 

Say you have a fan object and that fan has a on method. 
#+BEGIN_SRC Java
New fan; fan. On(); this is the simple stuff. 

complicatedExtraneousObject;

complicatedExtraneousObject.execute(fan object);

#+END_SRC

Basically you bought a fan and this came with a fancy switch. 
But you are a lazy person, so you bought another object that has the sole purpose of pressing the buttons of any object that is passed to it. 
That is the command pattern. 


** adapter pattern : fixed

This will be about the adapter pattern. So here it is. The thing is that in this case, you have two objects like two proper blobs of code. And they are of different types OK, this is because they are different objects and there is no intervening or common interfaces. 

But then you want to say aggregate the dissimilar objects together in a list, like an array-list. 
Now this cannot be done for they are of different types and there is no common interfaces between then. 
Here comes adapter pattern to the rescue. This is an extra blob of code, an object that will be like a bridge between the two original blobs, say a and b. So a and b will be bridged by this adapter. 
This adapter blob will implement blob a and will reference blob b. Let that sink in. 

It is kind of like standing between the two blobs a and b and is kind of like holding both their hands. 
Implementing one and referencing the other. 

The object that it is referencing is taken as argument in the constructor and internally it has assignment to the referenced objects. 

Well I was looking for the new keyword inside the class. A class which is not the main but rather the definition or the template of an object will never have a keyword, new. You will find new keyword in the main block. 

So that is that. 

So if you have two separate objects unrelated even by interfaces, say a and b. And if you wanted to group them in a list but could not due to the differences in type, you can do so now. 
You have to invent another blob and this blob sits between the blob a and b, implements one of them and internally references the other and takes the other object as argument and internally assigns that to the referenced object. 
Finally you can have a list of objects of both a and b types. 

Conclusion is that: if you thought that you could only list object of a certain type, if not by class supertype or abstract type then by the interface type. 
Wrong

You can also group together objects of types that are not the same and even if they do not have a common interface. 
Now that you think about it, this can be done for all sorts of objects however dissimilar they might be. 

This might work as follows, 
Create a object, create b object now pass b as argument to the adapter object and assign to a variable. Take a and converted b and put them in a list. 




** factory pattern :fixed

So moving on with the whole java thing. 

So far covered, the factory method and this includes the factory pattern and the abstract factory. Why is it the factory method, should it not be factory pattern. 

There after we have the singleton pattern. 

What I am trying to do is try to explain things in my own terms, like I clump together all the interfaces or the classes and the sub-classes into a single blob. And that makes it easier to comprehend all of these patterns. 

The adapter pattern. 

Factory: originally you have two blobs but then you invent a third blob as a go between. 

Singleton: you had a single blob, but then you modify the code with some keywords. 

Adapter: you had two blobs but then you invent a third blob as a go between. 

Command: original single blob but then you invent another blob to execute the functions of first blob. 


** decorator pattern : fixed

Decorator pattern: can I make this simpler. 

This is a single big blog, a dog chasing its own tail or a snake devouring its own rear end. 
All of it is a single blob or under the same big class. 
In the sub-classing department too, there is more than a single stage of branching. 

Let us consider two big blobs. One is the core_beverage and the other is the beverage_decorator and both of them are abstract and are subtended by a super blob called beverage. All of this the bifurcation or triangle are abstract. 

Now for the concretes. The core_beverage can be tea or coffee object. 
And the beverage_decorator could be milk object or sugar object. 

Classes abstract or otherwise have methods or functions. The super abstract class has a method description and another method cost. 

This is inherited by all of the sub-classes. So the tea, coffee object as well as the milk and sugar object have this function or method. 

In the sub-classes the concrete sub-classes, these methods need to be overridden to return custom description and cost. 

The beverage decorator is abstract class and it is there just for the sake of collecting all those concrete objects under the same umbrella, never mind that it is mostly empty. Just an empty blob that sub-classes other concrete blobs, even if it itself is mostly empty. 

Just like an empty or mostly empty blob that branches into multiple blobs loaded with functions. 
The majority of the actual code that does most of the work is itself concentrated in the decorator concrete classes. 

It would be better if we were to treat this as the case of two blobs. The core blobs and the blobs that have the wraparound capability that is to accept another blob as argument. This blob that is taken as argument might also be a composite. The blob that takes a composite blob does not worry about what it is accepting, it only sees the blob that is the outermost. The inner blobs are hidden from the wrapping blob. 



The twist being that these two core blob and wrapping blob are differentiated from each other by immediate super abstract blob and then again they are made to be of common types by yet another super super abstract blob. 

So for decorator you really start with two types of blob, the core blob and the wraparound blob. The wraparound blob can take the core blob as well as wraparound blob as arguments. 


** template pattern : fixed
#+BEGIN_SRC Java
duck duck;
if (blah)
duck duck1 = new dododuck;
else if (blah blah)
duck duck2 = new fododuck;
etc

#+END_SRC

Here is something that is being called as the template pattern. Given two well defined blob but then they do have similarities and then we do something like follows. 

Say for example you have tea and coffee and since they are both caffeine based beverages, we could like make their recipe and since that thing has similar components we could then maybe put then in a way that what is left in the concrete coffee or concrete tea is the very minimum. All of the common components we shove then up the abstract super classes which are anyways abstract, they have to be abstract. 

What cannot be put in the higher super classes and has to be put in the lower concrete classes has to be declared as abstract in the higher classes. This is wrong. Example brew() and condiment() these are common in tea and coffee but internally or their implementation is totally different so they are defined in the concrete sub classes but put in the higher abstract classes due to the common name but then declared as abstract and obviously left to the implementation below. 

Basically what they did was take two sort of like a well defined blob and then since in both cases or in case of any blob which can be divided vertically into abstract and implementation and since we do this for both the blobs, we can see components that might be common to both of them, the upper part of the blob or the abstract blobs can be unified into a single blob. And we strive to make the upper abstract or commanded blog as big as possible and the lower implementation blob as small as possible. 

This is being called as the template pattern, what we have done is taken two blobs and in each case divided vertically and then encapsulate what was in the upper part of the blob as a common plan or a common template and the lower part of the blob as the bare minimum unique implementation. 


Template pattern: take two blobs, divide vertically and see if there is similarities, if there are similarities commonify them, or template them. Make the upper blobs bigger and bigger and the lower unique implementation blob smaller and smaller. 

Here is more on this. 
Take a blob, any blob, it is obviously divided into two parts, the abstract sub blob and the concrete sub blob. Try to make the abstract sub blob bigger and the concrete sub blob smaller. Also make the abstract sub blob drive the entire blob rather than the concrete sub blob. The abstract sub blob should be in charge, not the concrete sub blob. 

This is idiotic enough. 
So how do you start with the application of the pattern business. 
In each case regardless of the pattern thing, you have the individual objects to which the functions are relegated or delegated but then you can take that as a blob, a mass of dough really and after kneading it to soft smooth ball, you can then divide it into two bits, the abstract bit and the concrete bit. This is regardless of the big picture or what pattern is being implemented. 

So this is my thinking, that you start with your usual functions and then you tie them up with objects and you determine as to how many objects you would be needing and then you divide the objects vertically. Now stand back and look and see what pattern can be implemented on it, and you might need to invent fictitious other objects or blobs, like in the case of factory or adapter etc. 


Update about the template pattern. This has to do with a single blob, you have in this undivided blob. A set of steps, like func1 func2 func3 till funcn. What they have done is take that and then put it inside a big method called the recipe and put all those functions in there. Now you put this big composite method and put it in the head part of the now vertically divided blob. So that the super abstract part will have this composite method with the serial functions. The implementation of those functions will get distributed between the abstract super part and the concrete part, depending on common components of the different blobs of the bigger picture, depending on how many blobs you are dealing with like maybe coffee blob and then tea blob and so on. 

So the thing is that the defining part is the composite function blob in the head part of the blob. 
Regarding hooks: you have the single blob, which you divide into two blobs the abstract and the concrete blobs. 

So you might have a function and there might be two versions of it. Either can be triggered at run time. 

You put one implementation in the abstract super part and another implementation in the concrete part. 
And if this were the template, you could, scratch that, forget any reference to template. 

In either of the blobs that is vertically, you have this composite function that is basically a recipe, 
 it would say something like

func1; func2; func3; ... funcn;

One of them func is implemented both in the super abstract part and the concrete part. 
And in that composite function, the recipe will go like follows

func1, func2, func3, if some Boolean then func4; func5; func6; ... funcn;

That func4 has an implementation in the abstract head part and another implementation in the concrete part. 

This will be triggered by user input of some Boolean. 
If Boolean then trigger the implementation of func4 in the head part; else something else will happen. 

The composite function could go like this

#+BEGIN_QUOTE
func1; func2; func3; if Boolean func4 or else func5; func6; .... funcn;

#+END_QUOTE



Is this the hook. 

Sorry, another attempt at explanation. 

The composite function would look like

#+BEGIN_QUOTE
func1; func2; func3; if myboolean() then func4 else func5; func6; .... funcn;
plus a default value for the myboolean() is supplied in the abstract part.

myboolean(){ return true}

this myboolean() can be overridden in the concrete part/ by user input.

#+END_QUOTE





So there are two of these
#+BEGIN_QUOTE
myboolean() in the head part with the default implementation
and myboolean() in the concrete part with the alternative implementation.

myboolean(){return true as default}
myboolean(){ take user input as Boolean and return that}

#+END_QUOTE

As far as hooks go, there are three parts to it, two of the implementations are there one is the default and the other triggered by the specific Boolean. 

And then the third part is the conditional block that will trigger the hook. This is included in the recipe. 


The Hollywood principle or pattern, don't call us we will call you. 
They talk about high level and low level, which is high and which is low. 

When we look vertically, we would see that the higher abstract part of the blob is the higher part. 
And the concrete bits are the lower part. 

Ideal: the higher bits should be in control, not the lower bits. 
The higher bits should call the shots, not the lower bits. 

Who depends upon whom. 

Ideally: the lower bits should depend on the higher bits. The higher bits are in control, they should not depend on the lower bits. 
Looking back in the template pattern, which concerned a single blob, divided into two traditional, high and low blobs. 

The template pattern or the recipe thing is not in the concrete part but in the abstract higher part, so the higher abstract blob is in control, not the lower concrete part. 

Hollywood pattern: if you have divided a single blob into two, the high and the low, place the recipe or the method calling all other methods in the higher abstract part. 

Contrast the Hollywood pattern with the dependency inversion. 

Did they use dependency inversion in factory. 
Factory: given two blobs where one blob creates the other blobs, create a third blob as a go between, so the original two blobs become untangled from each other. 

Consider original two blobs. 

#+BEGIN_QUOTE
blob1 and blob2;
now we invent a third blob, blob3.
blob3 calls or creates blob2;
blob2 depends on blob3;
blob3 is called upon by blob1;
blob3 depends on blob1;
blob1 blob3 blob2
blob1 calls blob3 calls blob2

#+END_QUOTE

Is it really?

Remember in the factory, the two blobs, the concrete bits have the factory pattern. 

This is confusing
#+BEGIN_QUOTE
Blob2 depends on blob3; blob3 depends on blob1; blob1---->blob3<----blob2; this makes sense. But what makes you think that blob1 is higher in hierarchy than blob2; or maybe that is not the issue here. 

#+END_QUOTE

That does makes sense
#+BEGIN_CENTER
blob1---> blob3<--- blob2

#+END_CENTER

Whereas in case of Hollywood principle, the dependency thing is within a single blob
#+BEGIN_QUOTE
blob == blob_abstract + blob_concrete;

blob_abstract --->  blob_concrete; (the Hollywood principle)

#+END_QUOTE

More confusion, 

Given blob1 blob2 and blobf for factory blob. 

blob2 depends on blobf or blobf <--- blob2; blob1 does not depend on blobf or blobf ---> blob1; or blob1 <--- blobf --- blob2

blob1 <--- blobf <--- blob2; inside blobf blob-abstract depend on blob-concrete or blob-abstract ---> blob-concrete;    blob1 <--- blobf-abstract ---> blobf-concrete <--- blob2; is this what they are trying to tell us.

With hollywood principle, blob-abstract <--- blob-concrete and not blob-abstract ---> blob-concrete. 

What could be the use of Hollywood principle or pattern. Blob-abstract <--- blob-concrete. The abstract bit could have all the hooks, well within the template. 

So the different patterns or methods so far. 

The hook pattern was kind of like contained in the template pattern. And this was more or less related to the Hollywood pattern. So it is like the template, the Hollywood or the hook all pertain to a single blob. 

So you could have three blobs as in factory, with original two blobs and the third factory blob. Barring the factory blob the other two blobs could incorporate the template or Hollywood pattern and might also contain hooks. 

What are your thoughts about the similarity between the factory and the adapter patterns. 

How to warm-up for a sit-up or push-ups?

Interface comparable and method compareTo(); interface comparable seems to be a system library. 

So you have objects, blobs and we would want to put them in an array. You want to compare anything that is in an array. 

And you want to sort them. 

So you build your blob with the following way
#+BEGIN_QUOTE
myblob implements comparable(){ blah blah}

and inside it you have to define your compareTo() method.

compareTo(blob otherblob){if thisblob > otherblob or thisblob==otherblob or thisblob < otherblob}

#+END_QUOTE

idk,

int compareTo(blob otherblob){thisblob > otherblob, return 1; thisblob < otherblbo return -1; thisblob == otherblob , return 0}

Or maybe the return type could be string


string compareTo(blob otherblob){thisblob >  otherblob, return "more"; thisblob < otherblob, return "less", thisblob == otherblob, return "equal"}

Since the interface comparable is a system one, the methods therein are all defined inside and are not really something that you bother with, it has the method sort and everything. So you just use them. They are defined as static, (i have no idea what that means). It says you have to use it in the following way

array.sort(myarray object).

That is it. 


And how is this a template pattern, I cannot see a template pattern in there. 

Is it because in the class def, there is the compareTo() method which goes like if blah then blah, els
Eif blah then blah and so on. 

Idk

This is nice, the blob might be called duck but we will name the array object as ducks;

The blob might be called bus but we will call the array object as buses;

Bird, birds; car, cars; plane, planes; etc

This chapter is more confusing then enlightening. 

Gobbledygook: strategy pattern uses object composition; what the hell is object composition. 

Very inadequate cursory glance at Jframe stuff. What the hell is it. It just shows a glimpse and some gobbledygook and exit. 

You wanna see page 357 for this, jframe thingy. 

Not much to see. 

For applets there is page 358, make whatever that you want to make of it. There is just not enough examples provided. 

Get an overview of template and strategy and come back to this page, 359. 

What is object composition vis a vis strategy pattern. 

I forget, what was the difference between array and array-list

This one is difficult, there is the so called iterator thing. You can build one yourself, example given, and it is ugly or use one of the library provided one. Much hassle avoided. 

I have not digested as to what just happened but then I see components that make sense and then there are some that do not. Of the ones that do make sense are the broad ones like I see there are objects and then I see that they are creating object with new and then putting them in list like structures and then cryptically they are looping through the lists. 

Did you see any of the previous examples of patterns. They all seemed very straightforward. 

Two blobs being taken in by another blob. This is not a factory or no template or whatever. No singleton. This is just plain old mush. 

Those uml diagrams, I hate those, they just make the simple things more complicated. 
At this stage we should probably take a look at all those list structures and how to loop through them. 
Get some understanding and build our own understanding of it. 


** thinking about java oop : fixed

The thing is that when you are writing code and you are like you have all the components in the form of different classes and interfaces and you have sorted them into packages and which is anyway a sort of an afterthought and the public private and all that sort anyway is an afterthought anyway. The thing is that when all of this is done by anyone it is perfectly understandable or legible and it is all right, you put them into the respective packages or folders and zip or whatever and all it a jar file or whatever. 

The thing is that the person who later on will have a look a the source file and will see a smattering of file laying around in random directories there is no overview of the whole thing or how the thing works, there is no such kind of documentation or is there. 

I will have to look into this. But the thing is I have devised or really thought about an approach that might work. 

It goes like, you have a bunch of files, like java files in a bunch of directories(thank god there is not h and c files like in c) now you open a file and see the main constructor in that file and not that class and the constructor and how or what kind of args that it might be taking. Not that important, we just need the name of the class. Now we close that file and open another file and repeat the same procedure. 

Now we list all of those class names and we create a dependency map on a piece of paper, which one depends on whom and all this time you do not really need to get too hung up on the whole methods or functions thing. 

That should be it and just ignore the whole packages hierarchy deal. This will just do, this is what you are thought to recognize. And we just did that. 

Same kind of approach could be done in case of the c++ code but then I do not really have too much of understanding in that language. The only complication that you might run into the h files I guess. Idk what is the deal with all those h files anyway, the same kind of approach will suffice I guess, you jut down the names of the class and then you try to diagram or draw the relation Edwin them neglecting the many functions, only listing the important functions, the rest are not required. 



** treating collection objects in java as boxes ??

Now back to java stuff. 

There are always the so called collections like you have a  a list or something like that, you have the o called arrays or arraylists and what do you have, the hashtables or it is the hashlist thing. I will explain later as soon as I figure out what is really is or how does it differs from the array-lists. 

Now I want you to imagine a matchbox, there is this matchbox, a simple matchbox filled with matchsticks. Now regarding the box, it is a single unit not a two units like the box cover itself and the sliding box inside, bot of these are the same one unit. So basically the matchbox and the matchstick are two units like the box and the sticks. The sticks are one object and you have it defined with a class. Similarly the box it self is another object that you define with a class. 

The box is a class or an object that inside has this collection like maybe an array or array-list or whatever, we really do not care about the specific nature of it, so long as it is it a collection. So far so good. 

In this collection that is the box we put in all those other objects, the sticks. 

That is quite nice picture. 

Now in the olden days to iterate over this collection, it was a simple for loop but in case of java, unlike other languages it is or seemingly more complicated, it looks complicated to me. But now there is no more worry for you can do way will all of that kind of chore. For now you just have to implement this particular interface and it would provide you with just two simple methods that you invoke like so
Array. This awesomemehtod(your object here)

And presto you have magic. That is so nice. 

And it works across all those myriad types of collections, you do not have to write variations of for loop methods for each of the collections. And this is a big win. 

A simple matchbox filled with sticks and it just has to implement this interface and those two or three methods become available for our use. Just like that. 

One question remains though, who is to implement that interface the box or the sticks. 
 
java , look at page 398


#+BEGIN_SRC Java
for files in myfiles; do blah blah
for (type object in collection) do blah blah
for (type object: collection) do blah blah
for (type object: myarraylist) do blah blah

#+END_SRC



 

Iterator pattern got more complicated. 

First there were two objects, the dinerhousemenu and the pancakehousemenu. And we have created a waitress object. 

So there are three objects in total, waitress object, dinerhouse menu object and pancakehouse menu object. Three blobs in total. 

What does the dinerhouse menu object or the pancakehouse menu object contain. 



Pancakehouse menu objects and the dinerhouse menu object has collections, consider the image of match sticks packed inside a match box. Pancakehouse menu object is a matchstick box such that in the class itself they have defined the various matchsticks and then later proceeded to pack those sticks inside the box. 

Let us consider that all over again. 

Start with the original objects, the dinermenu object and the pancakehousemenu object. 
Dinermenu or the pancakehousemenu objects are collections. 
They are collections in the sense that they have the collections like array or array-list and they populate those collections as well. 

Waitress is an object that takes as argument the dinermenu and the pancakemenu objects (collections) as arguments. 

The answer to all your confusion is the java. Util. Iterator
What is this anyway. 
 
There are different types of collections and since they are different, the many methods that are used to iterate through them would be different, like if you were to for loop through two different type of collection, the implementation of those methods would be different. You need some common, uniform kind of functions or methods to get through all of the different kind of collections. 

What I was hoping for was something completely different. Like if you have some kind of objects which is a collection type then, you could just slap to it some function like the for loop function (obviously this means that the class of that object has to extend some hidden system class or library). 
 
Like say we have some collection objects, 

Myobject1, myobject2, where say myobject1 is a hashtable kind of collection and the myobject2 is a array type of collection.
 So I wanted it to be like

#+BEGIN_SRC java
Myobject1. For_loop_through_this() ;; <-- this sort of thing does not exist. 

#+END_SRC

There is however an interface a big hidden interface called the iterator that towers or presides over all the different type of collections or rather you have to manually implement that interface in your class definitions. 

As we all know the interfaces only have the declarations of the different functions and no implementations. So you have those hasnext() or next() but there is no implementation. 

Really, I expected more from interfaces, what is the use of interfaces if they are just empty shells. 

Originally you had two objects, the dinermenu object and the pancakemenu object. You make another class, this guy generates iterators from whatever collection is passed to it. 

Nope, not a single class but two separate classes, one for each of the menu kinds/ or collection types
Dinermenu object, dinermenu-iterator object and for the pancakemenu object we have the pancakemenu-iterator. 

Dinermenu-iterator and pancakemenu-iterator can be visualized as empty shells into which you are passing the two objects, dinermenu and pancakemenu. So these are basically collections, array or array-list. And these dinermenu-iterator and pancakemenu-iterator take these collections as arguments and internally they deal with the collections by means of defining functions or methods that were already described in the interface iterator. These basically have the implementations of the methods hasNext() or next() and remove() and so on. 

Waitress object takes as argument these two objects / collection objects and internally creates the two iterators

#+BEGIN_SRC java
New dinermenu_iterator(dinermenu which was passed as argument)
New pancakemenu_iterator(pancakemenu object);

#+END_SRC

Now the waitress can deal with or work with these two iterators, like display stuff from the two collections or doing stuff to the collection. 

Only problem with this :

Started with two object / collection types/ there could have been more than two. And we had the waitress object. Had to create two more classes, iterator classes for each collection type. So the waitress object internally creates the iterator objects. 

For each collection type, you would create an extra blob that deals with that collection type blob. Kind of like wrapper stuff. 

Almost like collection type object deals with waitress object. 

Now you create an iterator object as an intermediary. 

So the iterator object sits between collection type object and the waitress object. 

The one thing that they could have helped with is the bit about the intermediary classes, the iterator classes. You do realize that the whole iterator classes are kind of like sham, just empty shells that you could have put in copy pasted code to implementation of the next(), hasNext() functions. And maybe that is where the power of the iterator classes lie, they are empty shell, a wrapper, it could just have been some copy pasted code. 

So at the end it looks like follows. 

The classes that contain the collections and then they are passed to the object (in this case waitress) to deal with them. That is where and how the dealing between waitress and the different object is modified. The iterator is taken out of the waitress and put out into an external object. 
This sums up the iterator object. 

Something seems to have changed. 

You had original two items, dinermenu object and pancakehousemenu object, these are both collections. They have to work with waitress object. 

Place dinermenu object and pancakemenu object blobs under a superblob called menu (an interface). This superinterface has a method, create-iterator(). 

How does create-iterator() works. It just wraps around the collection object and the method iterator(),  which is the library method. Which you can apply since all kind of collections fall under that superclass or super interface anyway. 

How does create-iterator() works. It just wraps around the collection object and the iterator() function. 

Basically

#+BEGIN_SRC java
this_collection_object.return_menu().iterator(); this is returned

#+END_SRC

remember i had to make fictious or placeholder classes for each of the collection type and then place the implementations there. (do i still need that)
#+BEGIN_SRC java
class dinermenu_iterator( dinermenu object){

all the implementations of next() or isNext() and so on}

collections object, dinermenu object; dinermenu.return_values().iterator() ; <-- wrapped around in collections.create_iterator();

collections_object.return_values().iterator(); <-- from collections_object.create_iterator();

#+END_SRC

Does this mean I do not need to implement those iterator stuff next() hasNext() and so on. (the book is not very clear about this)

Search these terms: java collections framework. 
Classes that are part of java collections framework


** iterator pattern: waitress object fixed
The waitress object has these new tools

#+BEGIN_SRC java
iterator dinermenu_iterator = new ???? ; <--- going up the wrong tree, there is no new. no constructor?
iterator dinermenu_iterator = dinermenu.create_iterator(); <--- this is the way to do it.

#+END_SRC

The type iterator, has all the fancy methods, next(), hasNext() and many others.
#+BEGIN_SRC java
iterator arraylist_collection_object_iterator = arraylist_collection_object.create_iterator();

iterator array_collections_object_iterator = array_collections_object.create_iterator();
iterator hashtable_collections_object_iterator = hashtable_collections_object.create_iterator();

#+END_SRC



The waitress uses the generic iterator type, and does not need to provide individually for each type of collections object. 

The composite pattern: this is something that was built to relieve one deficiency of the iterator pattern. 

Iterator pattern: you have objects that are really collections like hashmap or arraylist and arrays etc. 

The iterator pattern allows for creation of a superblob and into this blob we add the other blobs like the collection object blobs. All the collection object blobs go under this superblob. And this superblob has this createiterator() function. 

What this pattern allows us to do is to do the following. 

All the blobs, the collection blobs will extend an interface. So they are of the same type. So a similar type of an iterator. 


** composite pattern fixed

Move over this. Now we have the composite pattern. 

Given different collection objects, now we will make a super collection object and all those collection objects inside the super collection object. It might be an array of arraylists, hashtables, arrays etc. 
Now we have to add all these blobs into a blob which is then fed to the waitress. 

All the composition blobs used to make a superblob, usually an array object or arraylist object, now add this bigger array or arraylist object into another blob which is then fed to the waitress. 

The structure of this blob, which is different from the blob used in iterator pattern is interesting, so interesting that I am having difficulty understanding it. 

In the previous case, the iterator pattern case, you were adding the collections object directly. 

In the composite pattern case you will make a composite of all the collections object given and then add it to the blob. 

The blob has the ability to identify nodes and leafs and it knows when it is a composite, or it can traverse the complex tree structure that is passed to it. 

#+BEGIN_SRC java
iterator pattern case would look like the following.
waitress(big_blob(blob1, blob2, blob3))

composite pattern would look like
waitress(big_blob(composite_blob(blob1, blob2, blob3)))

#+END_SRC

We can clearly see that the big_blob has to deal with the composite_blob, that is the big_blob has to k
Now how to traverse the tree structure of the composite_blob. 


The benefit in either case being that, given that waitress and the collection blobs are at the extreme end  of the spectrum, we want them to be independent of each other, hence the intervening structures or blobs. 

Making the waitress and the composition objects as independent as possible is made by the composite pattern. In iterator pattern you have to open up waitress each time you make changes to the composition object, whereas in the composite pattern that has been taken care of. 

#+BEGIN_SRC java
waitress(big_blob(composite_blob(blob1, blob2, blob3)));

#+END_SRC
on this composite pattern i got some more ideas


yeah regarding the composite patern
#+BEGIN_SRC java
waitress(big_blob(composite_blob(blob1, blob2, blob3....)));

#+END_SRC

The most complicated part in this would be the big_blob

This big_blob is not really a single object but you might say that it is two objects. But still you have to call it a single object. This is confusing and why is this. 

One: big_blob made of super abstract class which is subtended by or extended by two concrete classes, still not sure as to what they really do. But if I may risk a guess, one of them takes the composite object as argument, and what about the other, nope, I am not very sure as to what these two objects are doing. But even if I do not know the function of the said object. It is clear from the context or the picture that the two objects are horizontally related. Hold it now, are you sure. 

#+BEGIN_SRC java
super_abstract_class(concrete_class1, concrete_class2);
we will make to more weird.
super_abstract_class(concrete_class1, concrete_class2(super_abstract_class));

#+END_SRC

** the back curving arrow fixed

See, the top node is related to one of the branches, you might say there is a horizontal relationship. 
In the uml or diagram thing the top or super abstract_class subtended two concrete classes and it was shown by arrows, like it is normally done but one of the arrows branches back onto the parent abstract class. <-- see the above condition. 

Parent node related to one of the branches. 
Parent node has a horizontal relationship with one of the subclasses. 

This kind of curving arrow was encountered before too but then I did not catch on that. 

The thing is that there is a way to name this kind of relationship. 
Idk, what would you call it. 
On the other hand, I have till now maintained a strict separation of the vertical relationship versus the horizontal relationship. 
In the following

#+Begin_SRC java
waitress(big_blob(composite_blob(blob1, blob2....)));

#+END_SRC

We can say that there is a horizontal relationship between waitress, big_blob, composite_blob and n number of collection blobs. 

These have a horizontal relationship. 

Also the composite blob, though a class was not declared for it, still it counts as a discrete object and hence, it is reasonable to consider it a blob. 

There might be super abstract blobs that are hidden in the form of java library but then as much as possible we will disregard them. And consider only those blobs or superblobs that are visible in the code body. 

That weird relationship between those objects which extended a super abstract object thus making a single blob or by virtue of the vertical nature they were a single blob but then the concrete blobs which can have an independent existence and one of them was related to the other, like the parent type was acceptable to one of the child branches. This is the weird relation that I am talking about. I have seen this before and that weird back curving arrow. 










** composite pattern fixed

In the composite pattern we have the menu object, the menu class, despite the constructor which takes a string or two in the constructor, does not really have anything to do with it. It initializes an arraylist and that is what is the deal with menu. So the constructor has nothing to do with how it has to or has the main deal of creating and populating an arraylist. 

The constructor could have been blank and it would not have made much of a difference. In this point the constructor is just like those tags or labels on a jar. If you create a jar the constructor mandates that you put in a name and description in the label. 

Marker page 412 : component pattern or sorry, it is composite pattern

** strategy pattern

Now to start from the very start. 
First a single blob, duck blob. 
Then three blobs, duck blob, quackable blob and flyable blob. 
Duck is a superclass, quackable and flyable are interfaces. 
The concretes are shared between the three super classes or interfaces. 
This just got complicated. 
Just got complicated. 

#+BEGIN_SRC java
duck(a1, a2, a3, a4 ....); where a1, a2, a3 etc are concretes
flyable(b1, b2, b3, b4 ...); where b1, b2, b3 are classes, concrete single blob classes.
quackable(c1, c2, c3, c4 ...); where c1, c2, c3 ... are classes, single blob concretes.

#+END_SRC
Can the duck concrete choose to implement interfaces, or is this doen by the super class above it.
#+BEGIN_SRC java
new concrete duck ( flyable object = new flyable concrete class of my choice, that is b1 or b2 or b3 or whatever;
quackable object( new concrete quackable object of my choice, that is c1 or c2 or c3 ... );

#+END_SRC
again reset;
#+BEGIN_SRC java
duck super parent abstract superclass ( concretes a1, a2, a3, a4 ....);
flybehaviour interface( concrete classes b1, b2, b3 ...)
quackbehaviour interface ( concrete classes c1, c2, c3 ....);

#+END_SRC


b1, b2, b3, b4 .... implement the flybehaviour interface;
c1, c2, c3, c4 ..... implement the quackbehaviour interface.

Parent super abstract duck class does not implement flybehaviour interface or quackbehaviour interface, it has references to then in the form of reference variables, "REFERENCE VARIABLES", flybehaviour myflybehaviour; quackbehaviour myquackbehaviour;

The main thing here are the super abstract class, the duck class, the two interfaces flybehaviour and the quackbehaviour. All the important things seem to happen in the super abstract class of duck, it has REFERENCE VARIABLES to flybehaviour and quackbehaviour. 

When you look at it and see how convoluted it is, you want to use something like uml or flowcharts but then that too gets confusing. 

What kind of arrows do I show for horizontal relationship. 

They are calling the flybehaviour and quackbehavior interfaces together with there sub classes that implement them as a blob an encapsulated blob. 

So two encapsulated blobs, the flying behavior and the quackbehaviour

And then there is the other blob, the duck blob. 

End this part, end this part. 

There is this saying

Prefer composition over inheritance. 

First of all you have the super abstract class, the class duck and then under it were the sub classes, the concretes. 

Then you took some of the attributes of the duck super class the quack behavior and the fly behavior and put it outside of the duck super abstract thing. In and interface, in two interfaces for two of them and then put the concrete sub classes that implement them under them. All those things or aggregates of it were said to be encapsulated. 

But that is not the point. 

The point is that since the attribute is outside of the abstract superclass and in an interface. The subclasses will not inherit the attributes by inheritance but by REFERENCE VARIABLES to the interfaces and your choice of concrete subclassses that subtend the interfaces. 

That is composition, not automatic inheritance of attributes. 

This above pattern is the strategy pattern. 

#+BEGIN_SRC 
strategy: super abstract blob(concrete1, concrete2 ....)

super abstract blob -->> attributes -->> take an attributes or two out of this blob and put it in an interface.
the interface cluster -->> encapsulated blob

#+END_SRC

So all your business blobs that is the concretes under the super abstract blob will use what is inherited from above and also use attributes from interfaces using REFERENCE VARIABLES. 

Strategy: start with inheritance. Take out attributes and put in interfaces. Destroy some inheritance and replace with composition. REFERENCE VARIABLES. 

Strategy pattern: first you have a blob, could be vertically divided, into branches, vertically divided so we do not care, this is vertically divided, why? you ask. Because the top half is abstract and the bottom half is concrete, that is why. 

This superblob, I mean the entirety, divide horizontally that is one is the blob and the other is an interface blob and another interface blob. Now the division is horizontal. Why horizontal, there is no abstract or concrete relation between them. They are independent. The main blob connects with the interface blobs with REFERENCE VARIABLES. 

The phrase "encapsulate what varies" ????

Imagine an innocent blob, take a closer look and it has a super abstract blob which subtends concrete blobs. Now we strike, we take that blob and look under microscope at what are the attributes that can be taken out, like finding the lowest common factor and we take them out and put them under interface. The cluster of interface and the concretes that implement it are said to be encapsulated. 

So the phrase "encapsulate what varies"

One that is common, this can do with inheritance. Keep it in the super abstract class blob. 

One that varies, this cannot be inherited by all, pull it out into discrete blobs called interfaces and their aggregates called encapsulated blobs. 

Inheritance for those attributes that are common. 

Composition for those attributes that vary. 

Composition: discrete interface blobs: keyword used in main blob -->> REFERENCE VARIABLES

The phrase "program to interfaces, not implementations"

Say you have blobs like proper blobs they might be vertically divided but then we are not considering the vertical divisions or are we. 

The blobs should refer to other blobs, but in a certain way. The arrow should point to the abstract part of another blob not to the concrete part of the other blob. 

#+BEGIN_SRC 
blob_a, blob_b, blob_c
blob_a has REFERENCE VARIABLES that point to blob_b and blob_c
blob_a has REFERENCE VARIABLES, that point to the blob_b_abstract-super and blob_c_abstract-super.
blob_a_concretes are free to choose their blob_b_concretes and blob_c_concretes.

#+END_SRC

the phrase "program to an interface, not an implementation"

"program to an interface, not to a concrete"

take a blob, a proper blob with vertical divisions. now pull out some attributes and put them into interfaces. hae the original blob point to the interface blobs so that the original blob points to the parent, root, abstract interface node , not the concrete branches. now you are free to do the concretes for all of them, and see how the important task of attending to the top layer or how the top layer of blob-a and blob-b and blob-c determines or gives you freedom when you make concretes of blob-a blob-b and blob-c.

uml is still kind of dodgy and throws me off.

